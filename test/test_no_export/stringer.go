// Code generated by "i18n-stringer -type code_no_export -output stringer.go"; DO NOT EDIT.

package test

import (
	"context"
	"fmt"
	"strconv"
)

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the i18n-stringer command to generate them again.
	var x [1]struct{}
	_ = x[HELLO-1]
	_ = x[WORLD-2]
}

const _code_no_export_name = "HELLOWORLD"

var _code_no_export_index = [...]uint8{0, 5, 10}

// String type to fmt.Stringer interface use default locale
func (i code_no_export) String() string {
	i -= 1
	if i < 0 || i >= code_no_export(len(_code_no_export_index)-1) {
		return "code_no_export(" + strconv.FormatInt(int64(i+1), 10) + ")"
	}
	return _code_no_export_name[_code_no_export_index[i]:_code_no_export_index[i+1]]
}

// _code_no_export_supported All supported locales and text offset information
var _code_no_export_supported = map[string]int{"zh-hk": 0}

// _code_no_export_defaultLocale default locale generated pass by i18n-stringer flag -defaultlocale, Don't assign directly
var _code_no_export_defaultLocale = "en"

// _ctxKey Key of set used locale from context.Context Value, Don't assign directly
var _code_no_export_ctxKey = "i18nLocale"

// WARNING: You should use Trans, Lang, Wrap, WrapWithContext method instead
//  - You should not use this method in an internationalized language environment, as well as method String.
//  - Because this method always returns the translation value of the default language.
//  - This method implements the error interface, so that you can return the value as an error,
//  - If you understand the above mechanism then you can use this method with confidence
func (i code_no_export) Error() string {
	return i.String()
}

// Wrap another error with locale set for i18n TYPE Const
//  - err another error
//  - locale i18n locale name
//  - args optional formatting component
func (i code_no_export) Wrap(err error, locale string, args ...code_no_export) *I18nCodeNoExportErrorWrap {
	return &I18nCodeNoExportErrorWrap{err: err, origin: i, locale: locale, args: args}
}

// WrapWithContext another error with locale set for i18n TYPE Const
//  - err another error
//  - ctx context with Value use Key from _code_no_export_ctxKey, which pass by i18n-stringer flag -ctxkey
//  - args optional formatting component
func (i code_no_export) WrapWithContext(err error, ctx context.Context, args ...code_no_export) *I18nCodeNoExportErrorWrap {
	return &I18nCodeNoExportErrorWrap{err: err, origin: i, locale: _code_no_export_localeFromCtxWithFallback(ctx), args: args}
}

// I18nCodeNoExportErrorWrap type i18n error wrapper
//   WARNING
//   This struct ONLY used to wrap the CONST generated by the i18n-stringer tool,
//   Pass easily obtain internationalized translations through Error, Trans, Lang
//   WARNING
type I18nCodeNoExportErrorWrap struct {
	err    error            // wrap another error
	origin code_no_export   // custom shaping type Val
	locale string           // i18n locale set
	args   []code_no_export // formatted output replacement component
}

// Trans get translated string
func (e *I18nCodeNoExportErrorWrap) Trans() string {
	return e.origin.Trans(e.locale, e.args...)
}

// Lang alias of Trans
func (e *I18nCodeNoExportErrorWrap) Lang() string {
	return e.Trans()
}

// Error struct as error, get translated string use Lang
func (e *I18nCodeNoExportErrorWrap) Error() string {
	return e.Trans()
}

// Format string form inside error and TOML define
//  - this method will be formatted wrap error. Only for development and debugging
func (e *I18nCodeNoExportErrorWrap) Format() string {
	if e.err == nil {
		return e.Error()
	}
	return fmt.Sprintf("%s (%s)", e.Error(), e.err.Error())
}

// Unwrap an error. Get the error inside
func (e *I18nCodeNoExportErrorWrap) Unwrap() error {
	return e.err
}

// IsLocaleSupport Check if the specified locale is supported
func (i code_no_export) IsLocaleSupport(locale string) bool {
	return _code_no_export_isLocaleSupport(locale)
}

// Lang get target translate text use context.Context
//  - ctx  context with Value use Key from _code_no_export_ctxKey, which pass by i18n-stringer flag -ctxkey
//  - args Optional placeholder replacement value
func (i code_no_export) Lang(ctx context.Context, args ...code_no_export) string {
	return i._trans(_code_no_export_localeFromCtxWithFallback(ctx), args...)
}

// Trans get target translate text use specified language locale identifier
//  - locale specified language locale identifier, need pass by IsLocaleSupport
//  - args Optional placeholder replacement value
func (i code_no_export) Trans(locale string, args ...code_no_export) string {
	if !_code_no_export_isLocaleSupport(locale) {
		locale = _code_no_export_defaultLocale
	}
	return i._trans(locale, args...)
}

func _code_no_export_isLocaleSupport(locale string) bool {
	_, ok := _code_no_export_supported[locale]
	return ok
}

// _code_no_export_localeFromCtxWithFallback retrieves and returns language locale name from context.
// It returns default locale when _code_no_export_isLocaleSupport is false
func _code_no_export_localeFromCtxWithFallback(ctx context.Context) string {
	if ctx == nil {
		return _code_no_export_defaultLocale
	}
	v := ctx.Value(_code_no_export_ctxKey)
	if v != nil && _code_no_export_isLocaleSupport(v.(string)) {
		return v.(string)
	}
	return _code_no_export_defaultLocale
}

// _trans trustworthy parameters inside method
func (i code_no_export) _trans(locale string, args ...code_no_export) string {
	return ""
}
