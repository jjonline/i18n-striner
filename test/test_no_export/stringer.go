// Code generated by "i18n-stringer -type code_no_export -output stringer.go"; DO NOT EDIT.

package test_no_export

import (
	"context"
	"fmt"
	"strconv"
)

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the i18n-stringer command to generate them again.
	var x [1]struct{}
	_ = x[HELLO-1]
	_ = x[WORLD-2]
}

const (
	_code_no_export_En_name   = "Helloworld"
	_code_no_export_ZhHk_name = "你好世界"
)

var (
	_code_no_export_En_index   = [...]uint8{0, 5, 10}
	_code_no_export_ZhHk_index = [...]uint8{0, 6, 12}
)

// _transOne translate one CONST
func (i code_no_export) _transOne(locale string) string {
	i -= 1
	if i >= code_no_export(len(_code_no_export_En_index)-1) {
		return "code_no_export[" + locale + "](" + strconv.FormatInt(int64(i), 10) + ")"
	}

	switch locale {
	case "en":
		return _code_no_export_En_name[_code_no_export_En_index[i]:_code_no_export_En_index[i+1]]
	case "zh-hk":
		return _code_no_export_ZhHk_name[_code_no_export_ZhHk_index[i]:_code_no_export_ZhHk_index[i+1]]
	default:
		// Normally unreachable, should not happen but be cautious
		return ""
	}
}

// _code_no_export_supported All supported locales record
var _code_no_export_supported = map[string]int{"en": 0, "zh-hk": 1}

// _code_no_export_defaultLocale default locale
// generated pass by i18n-stringer flag -defaultlocale, Don't assign directly
var _code_no_export_defaultLocale = "en"

// _code_no_export_ctxKey Key from context.Context Value get locale
// generated pass by i18n-stringer flag -ctxkey, Don't assign directly
var _code_no_export_ctxKey = "i18nLocale"

// WARNING: You should use Trans, Lang, Wrap, WrapWithContext method instead
//  - You should not use this method in an internationalized language environment, as well as method Error.
//  - Because this method always returns the translation value of the default language.
//  - This method implements the fmt.Stringer interface, so that you can output it directly by package fmt,
//  - If you understand the above mechanism then you can use this method with confidence
func (i code_no_export) String() string {
	return i._trans(_code_no_export_defaultLocale)
}

// WARNING: You should use Trans, Lang, Wrap, WrapWithContext method instead
//  - You should not use this method in an internationalized language environment, as well as method String.
//  - Because this method always returns the translation value of the default language.
//  - This method implements the error interface, so that you can return the value as an error,
//  - If you understand the above mechanism then you can use this method with confidence
func (i code_no_export) Error() string {
	return i._trans(_code_no_export_defaultLocale)
}

// Code get original type uint8 value
func (i code_no_export) Code() uint8 {
	return uint8(i)
}

// Wrap another error with locale set for i18n TYPE Const
//  - err another error
//  - locale i18n locale name
//  - args optional formatting component
func (i code_no_export) Wrap(err error, locale string, args ...code_no_export) *I18nCodeNoExportErrorWrap {
	return &I18nCodeNoExportErrorWrap{err: err, origin: i, locale: locale, args: args}
}

// WrapWithContext wrap another error with context.Context set for i18n TYPE Const
//  - ctx context with Value use Key from _code_no_export_ctxKey, which pass by i18n-stringer flag -ctxkey
//  - err another error
//  - args optional formatting component
func (i code_no_export) WrapWithContext(ctx context.Context, err error, args ...code_no_export) *I18nCodeNoExportErrorWrap {
	return &I18nCodeNoExportErrorWrap{err: err, origin: i, locale: _code_no_export_localeFromCtxWithFallback(ctx), args: args}
}

// I18nCodeNoExportErrorWrap type i18n error wrapper
//   WARNING
//   This struct ONLY used to wrap the CONST generated by the i18n-stringer tool,
//   Pass easily obtain internationalized translations through Error, String, Translate
//   WARNING
type I18nCodeNoExportErrorWrap struct {
	err    error            // wrap another error
	origin code_no_export   // custom shaping type Val
	locale string           // i18n locale set
	args   []code_no_export // formatted output replacement component
}

// Translate get translated string
func (e *I18nCodeNoExportErrorWrap) Translate() string {
	return e.origin.Trans(e.locale, e.args...)
}

// String implement fmt.Stringer, get translated string use Translate
func (e *I18nCodeNoExportErrorWrap) String() string {
	return e.Translate()
}

// Error struct as error, get translated string use Translate
func (e *I18nCodeNoExportErrorWrap) Error() string {
	return e.Translate()
}

// Format string form inside error and TOML define
//  - this method will be formatted wrap error. Only for development and debugging
func (e *I18nCodeNoExportErrorWrap) Format() string {
	if e.err == nil {
		return e.Error()
	}
	return fmt.Sprintf("%s (%s)", e.Error(), e.err.Error())
}

// Value get original type value
func (e *I18nCodeNoExportErrorWrap) Value() code_no_export {
	return e.origin
}

// Unwrap an error. Get the error inside
func (e *I18nCodeNoExportErrorWrap) Unwrap() error {
	return e.err
}

// IsLocaleSupport Check if the specified locale is supported
func (i code_no_export) IsLocaleSupport(locale string) bool {
	return _code_no_export_isLocaleSupport(locale)
}

// Lang get target translate text use context.Context
//  - ctx  context with Value use Key from _code_no_export_ctxKey, which pass by i18n-stringer flag -ctxkey
//  - args Optional placeholder replacement value
func (i code_no_export) Lang(ctx context.Context, args ...code_no_export) string {
	return i._trans(_code_no_export_localeFromCtxWithFallback(ctx), args...)
}

// Trans get target translate text use specified language locale identifier
//  - locale specified language locale identifier, need pass by IsLocaleSupport
//  - args Optional placeholder replacement value
func (i code_no_export) Trans(locale string, args ...code_no_export) string {
	if !_code_no_export_isLocaleSupport(locale) {
		locale = _code_no_export_defaultLocale
	}
	return i._trans(locale, args...)
}

func _code_no_export_isLocaleSupport(locale string) bool {
	_, ok := _code_no_export_supported[locale]
	return ok
}

// _code_no_export_localeFromCtxWithFallback retrieves and returns language locale name from context.
// It returns default locale when _code_no_export_isLocaleSupport is false
func _code_no_export_localeFromCtxWithFallback(ctx context.Context) string {
	if ctx == nil {
		return _code_no_export_defaultLocale
	}
	v := ctx.Value(_code_no_export_ctxKey)
	if v == nil {
		return _code_no_export_defaultLocale
	}
	if vv, ok := v.(string); ok && _code_no_export_isLocaleSupport(vv) {
		return vv
	}
	return _code_no_export_defaultLocale
}

// _trans trustworthy parameters inside method
func (i code_no_export) _trans(locale string, args ...code_no_export) string {
	msg := i._transOne(locale)
	if len(args) > 0 {
		var com []interface{}
		for _, arg := range args {
			com = append(com, arg._transOne(locale))
		}
		return fmt.Sprintf(msg, com...)
	}
	return msg
}
